-- Drop if exists
DROP TABLE projects PURGE;
DROP TABLE employees PURGE;
DROP TABLE departments PURGE;

-- Departments Table
CREATE TABLE departments (
    dept_id   NUMBER PRIMARY KEY,
    dept_name VARCHAR2(50)
);

-- Employees Table
CREATE TABLE employees (
    emp_id    NUMBER PRIMARY KEY,
    emp_name  VARCHAR2(50),
    dept_id   NUMBER,
    salary    NUMBER(10,2),
    CONSTRAINT fk_emp_dept FOREIGN KEY (dept_id) REFERENCES departments(dept_id)
);

-- Projects Table
CREATE TABLE projects (
    proj_id   NUMBER PRIMARY KEY,
    proj_name VARCHAR2(50),
    emp_id    NUMBER,
    hours     NUMBER,
    CONSTRAINT fk_proj_emp FOREIGN KEY (emp_id) REFERENCES employees(emp_id)
);
-- Departments
INSERT INTO departments VALUES (10, 'HR');
INSERT INTO departments VALUES (20, 'Finance');
INSERT INTO departments VALUES (30, 'IT');
INSERT INTO departments VALUES (40, 'Sales');

-- Employees
INSERT INTO employees VALUES (1, 'Alice', 10, 50000);
INSERT INTO employees VALUES (2, 'Bob', 20, 60000);
INSERT INTO employees VALUES (3, 'Charlie', 30, 70000);
INSERT INTO employees VALUES (4, 'David', 30, 55000);
INSERT INTO employees VALUES (5, 'Eve', 40, 45000);

-- Projects
INSERT INTO projects VALUES (101, 'Payroll System', 2, 100);
INSERT INTO projects VALUES (102, 'Recruitment Portal', 1, 50);
INSERT INTO projects VALUES (103, 'ERP Upgrade', 3, 200);
INSERT INTO projects VALUES (104, 'Data Migration', 4, 120);
INSERT INTO projects VALUES (105, 'Sales Dashboard', 5, 80);
INSERT INTO projects VALUES (106, 'Mobile App', NULL, 0);  -- Unassigned project

COMMIT;
==================================
üî• Nice ‚Äî you‚Äôre ready for some challenging **JOIN practice**!
I‚Äôll design a **realistic business problem** with **base tables, sample data, and tricky join queries** that test your SQL skills.

---

# üè¢ Scenario: Company Projects & Employees

We have 3 base tables:

1. **Departments** ‚Üí list of departments.
2. **Employees** ‚Üí employees belong to departments.
3. **Projects** ‚Üí projects assigned to employees.

---

## üîπ Step 1: Table Creation

```sql
-- Drop if exists
DROP TABLE projects PURGE;
DROP TABLE employees PURGE;
DROP TABLE departments PURGE;

-- Departments Table
CREATE TABLE departments (
    dept_id   NUMBER PRIMARY KEY,
    dept_name VARCHAR2(50)
);

-- Employees Table
CREATE TABLE employees (
    emp_id    NUMBER PRIMARY KEY,
    emp_name  VARCHAR2(50),
    dept_id   NUMBER,
    salary    NUMBER(10,2),
    CONSTRAINT fk_emp_dept FOREIGN KEY (dept_id) REFERENCES departments(dept_id)
);

-- Projects Table
CREATE TABLE projects (
    proj_id   NUMBER PRIMARY KEY,
    proj_name VARCHAR2(50),
    emp_id    NUMBER,
    hours     NUMBER,
    CONSTRAINT fk_proj_emp FOREIGN KEY (emp_id) REFERENCES employees(emp_id)
);
```

---

## üîπ Step 2: Insert Sample Data

```sql
-- Departments
INSERT INTO departments VALUES (10, 'HR');
INSERT INTO departments VALUES (20, 'Finance');
INSERT INTO departments VALUES (30, 'IT');
INSERT INTO departments VALUES (40, 'Sales');

-- Employees
INSERT INTO employees VALUES (1, 'Alice', 10, 50000);
INSERT INTO employees VALUES (2, 'Bob', 20, 60000);
INSERT INTO employees VALUES (3, 'Charlie', 30, 70000);
INSERT INTO employees VALUES (4, 'David', 30, 55000);
INSERT INTO employees VALUES (5, 'Eve', 40, 45000);

-- Projects
INSERT INTO projects VALUES (101, 'Payroll System', 2, 100);
INSERT INTO projects VALUES (102, 'Recruitment Portal', 1, 50);
INSERT INTO projects VALUES (103, 'ERP Upgrade', 3, 200);
INSERT INTO projects VALUES (104, 'Data Migration', 4, 120);
INSERT INTO projects VALUES (105, 'Sales Dashboard', 5, 80);
INSERT INTO projects VALUES (106, 'Mobile App', NULL, 0);  -- Unassigned project

COMMIT;
```

---

## üîπ Step 3: Challenging JOIN Tasks

### üß© Task 1: Show all employees with their department names and projects (if any).

üëâ Use **LEFT JOIN** across 3 tables.

```sql
SELECT e.emp_name, d.dept_name, p.proj_name, p.hours
FROM employees e
LEFT JOIN departments d ON e.dept_id = d.dept_id
LEFT JOIN projects p ON e.emp_id = p.emp_id
ORDER BY e.emp_name;
```

---

### üß© Task 2: Find all projects that are **not assigned** to any employee.

üëâ Use **RIGHT JOIN** or `WHERE emp_id IS NULL`.

```sql
SELECT p.proj_id, p.proj_name
FROM projects p
LEFT JOIN employees e ON p.emp_id = e.emp_id
WHERE e.emp_id IS NULL;
```

---

### üß© Task 3: Show **total project hours per department** (including departments without projects).

üëâ Needs **FULL OUTER JOIN**.

```sql
SELECT d.dept_name, SUM(p.hours) AS total_hours
FROM departments d
LEFT JOIN employees e ON d.dept_id = e.dept_id
LEFT JOIN projects p ON e.emp_id = p.emp_id
GROUP BY d.dept_name;
```

---

### üß© Task 4: Show employees who **work in the same department** (Self Join).

```sql
SELECT e1.emp_name AS emp1, e2.emp_name AS emp2, d.dept_name
FROM employees e1
JOIN employees e2 ON e1.dept_id = e2.dept_id AND e1.emp_id < e2.emp_id
JOIN departments d ON e1.dept_id = d.dept_id
ORDER BY d.dept_name;
```

---

### üß© Task 5: Show the **highest-paid employee in each department**.

üëâ Needs **JOIN + Subquery**.

```sql
SELECT e.emp_name, e.salary, d.dept_name
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id
WHERE e.salary = (
    SELECT MAX(salary) FROM employees WHERE dept_id = e.dept_id
);
```

---

### üß© Task 6: Show all possible team matchups of employees across different departments (like cricket fixtures).

üëâ **Self Join** variation.

```sql
SELECT e1.emp_name AS employee1, d1.dept_name AS dept1,
       e2.emp_name AS employee2, d2.dept_name AS dept2
FROM employees e1
JOIN employees e2 ON e1.emp_id < e2.emp_id
JOIN departments d1 ON e1.dept_id = d1.dept_id
JOIN departments d2 ON e2.dept_id = d2.dept_id
WHERE e1.dept_id <> e2.dept_id
ORDER BY dept1, dept2;
```

---
